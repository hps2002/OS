# 操作系统无论吞枣

## cpu执行程序的过程
cpu读取程序计数器的值获得指令在内存中的地址，cpu通过控制单元操作地址总线访问内存中的地址，并通知内存设备准备接收数据

数据总线将指令数据传入指令寄存器

程序计数器自增，自增大小和cpu位宽有关

分析指令类型，如果是计算类型的指令就将他分配到逻辑单元执行，如果是存储类型指令将它分配到控制单元执行。

*cpu不断从读取指令、执行指令之间反复循环，直到程序结束。不断循环的过程成为cpu周期*

## cpu缓存一致性
众所周知cpu和内存之前存在缓存，而cpu操作过后的数据也是存放在缓存的cache line中。所以要通过一些机制使得缓存中的数据能够和内存中的数据保持一致性。

有了内存为什么要存在缓存？
因为cpu的速度越来越快，而cpu到内存中取数据的速度相对太慢，所以在靠近cpu的地方设置一个缓存能补偿cpu访问内存的时间差。

有两种机制：写直达和写回
* 写直达是cpu操作完一个数据之后都将他写回内存中，无论他在不在cache，这样费时费力；
* 写回就是解决写直达增加总线负担的问题<br>
写回方法中，新的数据直接写入cache block中，直到“修改过”的cache要被“替换”的时候才将其写入内存。<br>
这样就缩短了总线在内存和cache之间的往返

上面的保持缓存一致性的方法都是基于单核cpu中，在多核cpu中保持缓存一致性要保证两个方面：写传播和事务串行化
**写传播**：让其他的核心知道当前的核心对cache中的数据做出了操作
**事务串行化**：让其他核心知道操作的顺序，需要引入一个锁的概念

可以通过总线嗅探的方法实现写传播和事务串行化，但是总线嗅探中要多次使用广播通知其他cpu，增加总线的负担。

于是使用MESI协议进行优化：
MESI协议是基于总线嗅探的基础上进行优化的，他的本质是一个有限状态机，通过不同状态之间的转化使得能够实现缓存一致性。

MESI标记的cache line有四个状态：
* 已修改（M）：M状态下的cpu已经对这个cache line已经进行修改，但是还没有写入到内存中
* 已失效状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。
* 独占和共享状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。

状态转移：
如果其他核心没有当前的cache block，是独占状态
如果多个核心拥有cache block但是数据是一样的，是共享状态
在共享状态下，某个核心A修改了cache block，核心A的cache block变为已修改，其他的核心变为失效
如果失效状态下要修改cache block，需要通知其他核心将数据写回内存，然后再修改cache block；

## 缓存伪共享
缓存伪共享问题出现在多核cpu中

什么是缓存伪共享？
假设有两个单独变量a、b，且a、b在内存上的物理地址连续所以a、b在读取的时候可能会在同一个缓存块中被读进cpu，核心A读取变量a、核心B读取变量b。根据cpu读取数据的规则：变量a存放在核心A的cache line中，同时核心A中的cache line也存在变量b； 变量b存放在核心B的cache line中，同时核心B的cache line中也存在变量a。
如果核心A对变量a进行修改，那么根据MESI协议要保证缓存一致性，会使得核心B中存放变量a、b的cache line失效，而核心B下一步要对变量b进行修改，那么要通知核心A将存放变量a、b的cache line写入内存中，核心B重新读取，并进行修改。如果核心A和核心B反复的出现这种操作，会使得MESI协议失效。导致cpu的性能下降

这就是缓存为共享。

解决缓存伪共享：
通过对变量a、b设置为cache line对齐，那么在cpu读取的时候就不会将两个变量读进同一个cache line中了，也就不出现上述的问题。

拓展：在c++中编译器对结构体中的变量进行内存对齐也是这个道理，为了增加cpu的吞吐量，所以要进行内存对齐，避免cpu频繁的读写内存。

## cpu选择线程
cpu选择如何选择线程，这是一个cpu调度问题：
在linux中，调度的对象是一个task_struct的数据结构。

在linux中，每个cpu都有自己的运行队列，其中又包括三个运行队列，dl_rq、rt_rq、cfs_rq优先级从高到低。

## 软中断
中断是计算机响应硬件请求的机制，操作系统接收到硬件的中断请求，会打断正在进行的进程，然后调用内核的中断处理程序来响应请求。

操作系统处理中断的过程要求短且快，避免过长的时间影响操作系统正常的调度，而且处理中断时间，中断请求出于关闭状态，所以中断处理程序执行过长的话会导致其他设备的中断请求丢失。

于是linux系统中提出了软中断的方法，来避免中断处理程序执行过长的时间和中断丢失的问题，将中断处理分成两个阶段完成，分别是上半部分和下半部分：
* **上半部分用于快速处理中断**，一般用来处理跟硬件紧密相关的事情和与时间相关的事情
* **下半部分用来延迟处理上半部分未完成的工作**，以内核线程的形式运行。

因此上半部分是**硬中断**， 下半部分是**软中断**

举个例子：
网卡通过DMA的方式接收网络包之后，将数据写入内存，然后通过**硬件中断**请求通知内核有新的数据到达，内核通过中断处理程序响应当前的中断请求，中断处理的过程分为两个部分：内核禁用网卡的中断，避免频繁硬中断，然后内核触发软中断，将耗时耗力的工作交给软中断处理程序。

硬中断会打断cpu正在执行的任务，立即处理中断程序；而软中断以内核线程的方式执行，不会直接打断cpu执行的任务。

**拓展**
linux中查看软中断运行情况的命令:cat /proc/softirqs
linux中查看硬中断运行情况的命令:cat /proc/interrupts

## 0.1 + 0.2 != 0.3
因为精度丢失的问题所以计算机中的小数小数相加可能不等于数学理论中的值。

计算机中存放小数是采取IEEE 754协议进行存放，一位符号位 + 8位指数位 + 23位尾数位置这是单精度浮点数

双精度浮点：一位符号位 + 11位指数位 + 52位尾数

对于0.1这种十进制的小数转化位二进制会出现无限循环的情况，但是存放在4个字节的float类型中肯定是要截取的，所以后面不能保存下来的数值就是精度丢失。

所以对于那种转化之后精度丢失的数只能取近似值，所以0.1 + 0.2 在计算机系统里面是不等于0.3的，只是最后的结果将近似值等于三而已。

## windows内核和linux内核的区别
内核其实是硬件和用户的接口


linux使用的是宏内核，就是将进程调度、线程调度、中断处理、硬件驱动等归为内核管理，同时linux允许驱动内核模块化。可执行文件是ELF格式<br>
linux内核理念是多任务、对称多处理、可执行文件链接格式、宏内核

windows使用的是混合内核，内核中存在一个小型的内核，其他模块在这个基础上搭建。可执行文件是PE

## 内存管理
逻辑地址：程序编译之后在段中管理的地址；
虚拟地址：通过段式内存管理映射的地址，也叫线性地址；
物理地址：在内存中的真实地址

### 分段
将程序的地址分成一段一段的，如代码段、数据段、堆段...

分段机制下虚拟地址组成：段选择银子 + 段内偏移量

通过段号查找段表，获得段基址，然后加上段内偏移量得到物理地址；

分段机制存在外部内存碎片的问题，因为在分段之后可能会存在一些不连续的小内存块，这时候没有办法被分配。要采取内存交换的方式进行分配，将某一块内存写到硬盘中，再读回来拼接到连续的内存地址上。不过这种方法如果出现程序较大的情况，会卡顿。所以效率十分低下。

### 分页机制
分页机制将物理内存划分为一个个页面，使用页面装载程序。

二级分页机制下的虚拟地址：一级页表号 + 二级页表号 + 页内偏移量

操作系统给程序分配内存的时候只分配一些内存，通过缺页中断进行置换的方法使得小内存运行大程序。

二级页表节省内存？如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。

为了解决页表多次转换影响效率，加入了TLB，页表缓存/快表，里面存放常用的页表项

### 段页式机制
* 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
* 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页

段页式机制：段号 + 段内页号 + 页内偏移

段页式机制地址转换：
* 第一次访问段表，得到页表起始地址；
* 第二次访问页表，得到物理页号；
* 第三次将物理页号与页内位移组合，得到物理地址。

### linux内存管理
Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

Linux的内存分布

每个程序分为内核空间和用户空间，程序之间有独立的虚拟内存，但是内核空间中关联物理地址是相同的，方便进入内核态之后访问内核空间的内存。

linux用户空间的分布：
* 内核空间，出于最高地址位在32位操作系统中内核空间大小位1G；
* 栈，存放局部变量、函数调用的上下文。栈大小一般为8M；
* 文件映射区， 包括动态库，共享内存等
* 堆，包括动态分配的内存，由低地址向上增长
* BSS， 包括位初始化的静态变量和全局变量；
* 数据段，包括已初始化的静态变量和全局变量
* 代码段，包括二进制的可执行代码
* 保留区，因为小数值地址不合法，防止程序出现bug使得程序跑飞了

### 虚拟内存的作用
第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。

第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。

第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

### 内存满了？
程序申请内存后，在虚拟内存中进行内存的分配，待到程序读到这块寻内存的时候，cpu访问虚拟地址，发现并没有被映射到物理内存上，于是发生了缺页中断，进程进入内核态，将缺页中断交给内核的缺页中断处理函数进行处理。缺页中断判断是否由合适的空余的物理内存，如果由就分配物理内存。

如果没有物理内存就进行内存回收工作，主要通过两种方式：后台内存回收、直接内存回收

内存回收之后还是没有内存，出发OOM机制通过算法选择一个程序杀死，直到由空余的物理内存。

可以被回收的内存：文件页和匿名页
* 文件页面：回收干净的页面是直接释放、回收脏页面要写回磁盘再进行释放，有I/O操作会影响性能。
* 匿名页面：堆栈中的数据，Linux中通过Swap机制写入交换区，有I/O操作会影响性能

回收两种页面都是基于LRU算法进行，维护双向链表active_list和inactive_list

#### 内存回收的影响
后台回收唤醒kswapd线程进行异步操作，不会阻塞进程。

直接回收，通过同步的方式进行回收，会阻塞进程，导致造成长时间的延迟，使得cpu负载飙升

针对回收内存导致的性能影响解决方案：
* linux中可以通过```/proc/sys/vm/swappiness```选项调整文件页和匿名页的回收倾向。swappiness的范围是0 - 100，数值越高越倾向回收匿名页，一般设置0，但是要注意设置0并不表示不回收匿名页。
* 尽早启动内存回收，Linux中当物理内存到达页低阈值的时候开始进行后台内存回收，到达最小阈值的时候开始进行直接内存回收。页高阈值和页低阈值都是通过最小阈值```/proc/sys/vm/min_free_kbytes```进行计算，所以可以通过调整最小阈值让系统尽早进行内存回收，但是这样会造成内存浪费。
* 在NUMA架构下调整内存回收策略，将```/proc/sys/vm/zone_reclaim_mode```设置为0，使得在回收每个Node本地内存之前寻找其他Node是否有空闲内存。

#### OOM机制杀死进程
如果在内存回收之后还是出现内存不够的情况就会触发OOM机制进行内存杀死，OOM killer 就会根据每个进程的内存占用情况和 oom_score_adj 的值进行打分，得分最高的进程就会被首先杀掉。

我们可以通过调整进程的 ```/proc/[pid]/oom_score_adj``` 值，来降低被 OOM killer 杀掉的概率。调整成-1000，当前进程不会被杀死。

### malloc如何分配内存
malloc如何分配内存？

malloc分配的是虚拟内存，当程序调用的时候会触发缺页中断

malloc()是一个C库函数，还需要系统调用进行mmap()或者brk()进行内存分配
* 当申请内存大于等于128k使用mmap()在文件映射区分配内存，free()之后归还操作系统。当执行malloc(1)的时候，会预分配较大的空间作为内存池。
* 当申请内存小于128k使用brk()在堆中进行分配，free()之后暂时不归还操作系统，停留在内存池中等待下一次分配

为什么不全部使用mmap()进行分配?

使用mmap()分配要进入内核态，频繁的状态切换会对性能造成影响。如果都用mmap()进行内存分配相当于每次都要执行系统调用。而且mmap()在释放后会归还操作系统，所以每次使用mmap()分配的内存在第一次被访问的时候就会出现缺页中断。因此通过brk()进行改进，brk()也是系统调用，不过brk()在第一次调用的时候就预分配较大的内存进入内存池，而且在free()释放内存会也不归还操作系统，而是缓存在内存池中等待下一次分配。

为什么不全部使用brk()进行分配？

brk()虽然可以通过内存池机制减少缺页中断和系统调用次数，但是如果每次申请大空间的内存会导致，小内存块出现`内存泄露`的情况，且valgrind检测不出来。


free()传入首地址，怎么知道删除多大的内存？

malloc分配内存时，返回给用户态的内存起始地址比进程的堆空间的起始多16字节。free()会向左偏移16字节，根据内存块头信息分析当前要释放内存块的大小。

